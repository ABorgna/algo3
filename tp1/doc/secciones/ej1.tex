\section{Problema 1: Cruzando el puente}

\subsection{Introducción}
		En este problema Indiana Jones, y sus arqueólogos, se alían a una tribu caníbal local para poder llegar juntos a la fortaleza que resguarda los secretos que tanto anhelan encontrar. Deben cruzar un puente que les presenta las siguientes dificultades:

			\begin{itemize}
				\item Solo pueden pasar dos personas a la vez.
				\item En cada cruce es necesario contar con la única linterna presente.
				\item No puede suceder que en algún lado del puente queden más caníbales que arqueólogos.
				\item Cada persona puede cruzar el puente a una velocidad particular. Si dos personas cruzan el puente, lo harán a la velocidad del que sea más lento.
			\end{itemize}

		El objetivo del problema es encontrar el tiempo mínimo necesario para que todos los integrantes del equipo lleguen, cumpliendo los requisitos anteriores, al otro lado del puente.
		\\

		En las siguientes secciones llamaremos $estado$ a la ubicación de: la linterna, cada arqueólogo y cada caníbal respecto del lado inicial.

		Podemos representar cada estado con dos vectores de tamaño N y M ($A$ y $C$ respectivamente) que indican, con un bool, si la ubicación del i-ésimo arqueólogo $A_i$ o caníbal $C_i$ es la del lado final. Además de una variable para la ubicación de la linterna. Por lo tanto, cuando todas valgan $True$, habremos llegado al lado final (la linterna no puede terminar del lado inicial porque requiere estar presente en todos los cruces). Por lo tanto, por enunciado tendremos que cumplir en cada estado:
		\\

		$\sum_{i=0}^{N}\beta(A_i) \ge 0 \Rightarrow \sum_{i=0}^{N}\beta(A_i) \ge \sum_{i=0}^{M}\beta(C_i)  $
		\ \ \
		$\wedge$
		\ \ \
		$\sum_{i=0}^{N}\beta(\neg A_i) \ge 0 \Rightarrow \sum_{i=0}^{N}\beta(\neg A_i) \ge \sum_{i=0}^{M}\beta(\neg C_i)$
		\\

		Para cada persona $k$, sabemos su velocidad $V_k$. También sabemos que la demora de llevar el par $\left \langle {X, Y} \right \rangle$, con $\{X,Y\} \subseteq A \cup C$ de un lado a otro corresponde a $Max\{ V_{X}, V_{Y}  \}$ y es, a su vez, la distancia entre dos estados distintos. De este modo, podemos modelar todas las secuencias de viajes posibles como un digrafo ponderado con estados como vértices y donde cada arista es un viaje con peso equivalente a la distancia entre sus vértices adyacentes. De este grafo, finalmente, buscamos la distancia mínima de todos los caminos desde el estado inicial al final que cumplen los requisitos comentados al principio.
		\\

		* inserte ejemplo aquí *

\subsection{Solución y Correctitud}
	\subsubsection{Solución}


	Para resolver el problema, lo que haremos es tener una cola de prioridad mínima de (Estado, Costo) y usaremos el costo para determinar la prioridad de cada elemento.
	Empezamos encolando el estado inicial y mientras haya elementos en la cola haremos lo siguiente.
	Se desencola el primer elemento, se mira su estado, si es el estado que estamos buscando, devolvemos el costo y termina.
	En caso contrario, a partir del estado que obtuvimos, nos generamos todos los siguientes estados posibles junto con el tiempo necesario para llegar del estado inicial a ese y el ciclo vuelve a empezar.
	En caso de no quedar mas elementos en la cola y no se haya encontrado una solucion se devuelve -1.
	A continuacion, presentamos un pseudo codigo de nuestro algoritmo.


\lstset{basicstyle=\large}
\begin{lstlisting}
	TiempoMinimo (Vector<int> arq, vector<int> can,estado res)

	TotalArq $\leftarrow$ arq.size
	TotalCan $\leftarrow$ can.size
	inicial $\leftarrow$ vector(TotalArq+TotalCan+1,false)
	distancia $\leftarrow$ CrearDicc(estado,int)
	candidatos $\leftarrow$ CrearConj(int,estado)
	Definir(distancia,inicial,0)
	Ag(candidatos,0,inicial)

	while candidatos $\neq$ $\emptyset$ do

		actual $\leftarrow$ Min(candidatos)
		borrar(actual,candidatos)
		if actual $=$ res
			devolver actual.costo
		else
	for cadaEstadoSiguientePosible do
		AgregarCandidato(distancia,candidatos,Tiempo(e),e)

\end{lstlisting}

Seudo codigo para generar todas las siguientes estados posibles
\lstset{basicstyle=\large}

\begin{lstlisting}
TO DO
\end{lstlisting}

\lstset{basicstyle=\large}
\begin{lstlisting}
	AgregarCandidato (Diccionario (estado,int) dicc ,Conjunto(int,estado) cola,int t, estado e)

	esta $\leftarrow$ esta?(dicc,e)
	if esta
			TiempoActual $\leftarrow$ Obtener(dicc,e)
				if t < TiempoActual
					Borrar(dicc,e)
					Borrar(cola,<Tiempo,e>)

	Definir(e,costo)
	Agregar(costo,e)

\end{lstlisting}

Esta funcion tiene un costo de O (Log(n)), buscar en un diccionario arboreo es de orden logaritmico si esta balanceado, comparar 2 enteros es O(1) 2 inserciones
y en ciertos casos 2 borrados, cada una de esas operaciones es del orden logaritmico


	\subsubsection{Correctitud}

Veamos que el algoritmo es correcto. Vamos a probar que obtiene siempre la distancia mínima a cualquier vértice del grafo. De ser así, podemos asegurar que el menor camino encontrado para el estado final en particular es efectivamente el mínimo.
\\

Vamos a usar inducción en la cantidad de vértices (estados) visitados en el grafo.
Sea $dist(v)$ la distancia desde el estado inicial obtenida por el algoritmo hasta el vértice $v$. Sea $\delta(v)$, el camino mínimo hasta $v$ y sea $V$ el conjunto de vértices visitados hasta el momento: tenemos que probar que $dist(v) = \delta(v)$ para todo vértice del grafo. Vamos a probarlo mediante induccion con el siguiente lema:
\\

% Estoy martillando esta dem
% https://web.engr.oregonstate.edu/~glencora/wiki/uploads/dijkstra-proof.pdf

\begin{center}
\textbf{Lema: } $\forall$ $v \in$ $V$, $dist(v) = \delta(v)$
\end{center}

\emph{\textbf{Caso Base:}}
\\

Un único vértice visitado. El único momento donde tenemos un solo nodo visitado es al comienzo, es decir
el estado inicial, el cual tiene distancia 0 (por definición) y es correcto trivialmente.
\\

\emph{\textbf{Hipótesis inductiva: }} Para todo vértice explorado anteriormente (es decir que está en $V$) nuestra distancia hallada es la mínima.
\\

\emph{Paso Inductivo:} Sea $u$ el último nodo agregado a $V$. Sea $V'= V + u$, necesitamos probar que $dist(u) = D_{min}(u)$ para terminar. Vamos por el absurdo, supongamos que nuestro algoritmo no encuentra el camino minimo: Supongamos que hay un camino más corto hasta $u$ que es $Q$, por lo tanto afirmamos sobre la longitud del camino $Q$, $L(Q)$, que
\\
\begin{center}
\textbf{I)} $L(Q) < dist(u)$
\\
\end{center}
Como $Q$ parte del estado inicial, que llamaremos $S$, y $S \in V$, entonces sabemos que $Q$ empieza en $V$ y en algún momento sale de $V$ para llegar a $u$. Sea $xy$ la primer arista donde $Q$ sale de $V$. Sea $Q_x$ el subcamino de $Q$ con todos sus vértices en $V$, es decir, el subcamino de $Q$ desde $s$ a $x$. Entonces:
\\
\begin{center}
$L(Q_x)+L(xy) \leq L(Q)$
\\
\end{center}
Aplicando H.I, $dist(x)$ es la distancia mínima desde $S$ hasta $x$: $dist(x) \leq L(Q_x)$ y por lo tanto, usando la desigualdad anterior:
\\
\begin{center}
\textbf{II)} $dist(x)+L(xy) \leq L(Q) $
\\
\end{center}
Como $y$ es vecino del vértice (ya visitado) $x$, ya llamamos a $agregarCandidato$ para $y$ iterando sobre $x$. Por lo tanto, o el camino mínimo que tenemos calculado para $y$ es el mínimo para $x$ seguido de la arista que va de $x$ a $y$, o encontramos en algún momento uno mejor. Por lo que vale:
\\
\begin{center}
\textbf{III)} $dist(y) \leq dist(x) + L(xy)$
\\
\end{center}
Por último, como $u$ fue el primer elemento sacado de la cola de prioridad que no pertenece a $V$, tiene menor o igual distancia al estado inicial que el resto de todos los que no pertenecen tampoco a $V$:
\\
\begin{center}
\textbf{IV)} $dist(u) \le dist(y) $
\\
\end{center}
Combinando II) con I) tenemos:
\\
\begin{center}
$dist(x)+L(xy) < dist(u)$
\\
\end{center}
Usando IV) y III) llegamos a:
\\

\begin{center}
$dist(x)+L(xy) < dist(x) + L(xy)$
\\
\end{center}
\textbf{Absurdo}, entonces $Q$ no puede existir siendo menor a la distancia calculada para $u$ y por lo tanto $dist(u) = \delta(u) \QEDB$
