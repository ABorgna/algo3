\section{Problema 1: Cruzando el puente}

\subsection{Introducción}
		En este problema Indiana Jones, y sus arqueólogos, se alían a una tribu caníbal local para poder llegar juntos a la fortaleza que resguarda los secretos que tanto anhelan encontrar. Deben cruzar un puente que les presenta las siguientes dificultades:

			\begin{itemize}
				\item Solo pueden pasar dos personas a la vez.
				\item En cada cruce es necesario contar con la única linterna presente.
				\item No puede suceder que en algún lado del puente queden más caníbales que arqueólogos.
				\item Cada persona puede cruzar el puente a una velocidad particular. Si dos personas cruzan el puente, lo harán a la velocidad del que sea más lento.
			\end{itemize}

		El objetivo del problema es encontrar el tiempo mínimo necesario para que todos los integrantes del equipo lleguen, cumpliendo los requisitos anteriores, al otro lado del puente.
		\\

		En las siguientes secciones llamaremos $estado$ a la ubicación de: la linterna, cada arqueólogo y cada caníbal respecto del lado inicial.

		Podemos representar cada estado con dos vectores de tamaño N y M ($A$ y $C$ respectivamente) que indican, con un bool, si la ubicación del i-ésimo arqueólogo $A_i$ o caníbal $C_i$ es la del lado final. Además de una variable para la ubicación de la linterna. Por lo tanto, cuando todas valgan $True$, habremos llegado al lado final (la linterna no puede terminar del lado inicial porque requiere estar presente en todos los cruces). Por lo tanto, por enunciado tendremos que cumplir en cada estado:
		\\

		$\sum_{i=0}^{N}\beta(A_i) > 0 \Rightarrow \sum_{i=0}^{N}\beta(A_i) \ge \sum_{i=0}^{M}\beta(C_i)  $
		\ \ \
		$\wedge$
		\ \ \
		$\sum_{i=0}^{N}\beta(\neg A_i) > 0 \Rightarrow \sum_{i=0}^{N}\beta(\neg A_i) \ge \sum_{i=0}^{M}\beta(\neg C_i)$
		\\

		Para cada persona $k$, sabemos su velocidad $V_k$. También sabemos que la demora de llevar el par $\left \langle {X, Y} \right \rangle$, con $\{X,Y\} \subseteq A \cup C$ de un lado a otro corresponde a $Max\{ V_{X}, V_{Y}  \}$ y es, a su vez, la distancia entre dos estados distintos. De este modo, podemos modelar todas las secuencias de viajes posibles como un digrafo ponderado con estados como vértices y donde cada arista es un viaje con peso equivalente a la distancia entre sus vértices adyacentes. De este grafo, finalmente, buscamos la distancia mínima de todos los caminos desde el estado inicial al final que cumplen los requisitos comentados al principio.
		\\

		\textbf{\color{red}* inserte ejemplo aquí *}

\subsection{Solución y Correctitud}
	\subsubsection{Solución}

	Para resolver el problema, utilizamos una mecánica basada en el algoritmo de Dijkstra para encontrar caminos mínimos en grafos. Lo que hacemos es tener en un $map\langle {estado,\ distancia} \rangle$ que nos va a permitir ir guardando, para cada vértice (estado) visitado, su correspondiente $distancia$ o tiempo mínimo calculado (hasta el momento) desde el estado inicial.

		Además del $map$, también vamos llevando los estados a visitar en un cola de prioridad respecto de los de menor distancia y los vamos desencolando, a diferencia del diccionario donde quedan los estados visitados para evitar pasar dos veces por el mismo vértice.
		Recorremos el grafo de manera similar al $DFS$ de un $backtracking$: vamos encolando todos los $hijos$ (aquellos que cumplen los requisitos del problema) de cada estado que vamos visitando con su correspondiente distancia. Si uno de ellos ya está encolado, actualizamos su distancia de ser menor la actual. La diferencia es que desencolamos aquellos estados que tienen menor distancia siempre. Esto, como veremos en la subsección de correctitud, nos va a permitir asegurar que, cuando nuestro estado actual sea el final, no haga falta seguir iterando porque efectivamente es la distancia mínima.
		De no haber conseguido llegar al estado final con los datos de entrada, la cola se vacía (porque se agotan todos los caminos posibles) y se devuelve $-1$.


\lstset{basicstyle=\large}
\begin{lstlisting}
	TiempoMinimo (Vector<int> arq, vector<int> can,estado res)

	TotalArq $\leftarrow$ arq.size
	TotalCan $\leftarrow$ can.size
	inicial $\leftarrow$ vector(TotalArq+TotalCan+1,false)
	distancia $\leftarrow$ CrearDicc(estado,int)
	candidatos $\leftarrow$ CrearConj(int,estado)
	Definir(distancia,inicial,0)
	Ag(candidatos,0,inicial)

	while candidatos $\neq$ $\emptyset$ do

		actual $\leftarrow$ Min(candidatos)
		borrar(actual,candidatos)
		if actual $=$ res
			devolver actual.costo
		else
	for cadaEstadoSiguientePosible do
		AgregarCandidato(distancia,candidatos,Tiempo(e),e)

\end{lstlisting}

Seudo codigo para generar todas las siguientes estados posibles
\lstset{basicstyle=\large}

\begin{lstlisting}
TO DO
\end{lstlisting}

\lstset{basicstyle=\large}
\begin{lstlisting}
	AgregarCandidato (Diccionario (estado,int) dicc ,Conjunto(int,estado) cola,int t, estado e)

	esta $\leftarrow$ esta?(dicc,e)
	if esta
			TiempoActual $\leftarrow$ Obtener(dicc,e)
				if t < TiempoActual
					Borrar(dicc,e)
					Borrar(cola,<Tiempo,e>)

	Definir(e,costo)
	Agregar(costo,e)

\end{lstlisting}

Esta funcion tiene un costo de O (Log(n)), buscar en un diccionario arboreo es de orden logaritmico si esta balanceado, comparar 2 enteros es O(1) 2 inserciones
y en ciertos casos 2 borrados, cada una de esas operaciones es del orden logaritmico


	\subsubsection{Correctitud}

Veamos que el algoritmo es correcto. Vamos a probar que obtiene siempre la distancia mínima a cualquier vértice del grafo. De ser así, podemos asegurar que el menor camino encontrado para el estado final en particular es efectivamente el mínimo.
\\

Vamos a usar inducción en la cantidad de vértices (estados) visitados en el grafo.
Sea $dist(v)$ la distancia desde el estado inicial obtenida por el algoritmo hasta el vértice $v$. Sea $\delta(v)$, el camino mínimo hasta $v$ y sea $V$ el conjunto de vértices visitados hasta el momento: tenemos que probar que $dist(v) = \delta(v)$ para todo vértice del grafo. Vamos a probarlo mediante induccion con el siguiente lema:
\\

% Estoy martillando esta dem
% https://web.engr.oregonstate.edu/~glencora/wiki/uploads/dijkstra-proof.pdf

\begin{center}
\textbf{Lema: } $\forall$ $v \in$ $V$, $dist(v) = \delta(v)$
\end{center}

\emph{\textbf{Caso Base: }}  Un único vértice visitado. El único momento donde tenemos un solo nodo visitado es al comienzo, es decir
el estado inicial, el cual tiene distancia 0 (por definición) y es correcto trivialmente.
\\

\emph{\textbf{Hipótesis inductiva: }} Para todo vértice explorado anteriormente (es decir que está en $V$) nuestra distancia hallada es la mínima.
\\

\emph{Paso Inductivo:} Sea $u$ el último nodo agregado a $V$. Sea $V'= V + u$, necesitamos probar que $dist(u) = \delta(u)$ para terminar. Vamos por el absurdo, supongamos que nuestro algoritmo no encuentra el camino minimo: Supongamos que hay un camino más corto hasta $u$ que es $Q$, por lo tanto afirmamos sobre la longitud del camino $Q$, $L(Q)$, que
\\
\begin{center}
\textbf{I)} $L(Q) < dist(u)$
\\
\end{center}
Como $Q$ parte del estado inicial, que llamaremos $S$, y $S \in V$, entonces sabemos que $Q$ empieza en $V$ y en algún momento sale de $V$ para llegar a $u$. Sea $xy$ la primer arista donde $Q$ sale de $V$. Sea $Q_x$ el subcamino de $Q$ con todos sus vértices en $V$, es decir, el subcamino de $Q$ desde $s$ a $x$. Entonces:
\\
\begin{center}
$L(Q_x)+L(xy) \leq L(Q)$
\\
\end{center}
Aplicando H.I, $dist(x)$ es la distancia mínima desde $S$ hasta $x$: $dist(x) \leq L(Q_x)$ y por lo tanto, usando la desigualdad anterior:
\\
\begin{center}
\textbf{II)} $dist(x)+L(xy) \leq L(Q) $
\\
\end{center}
Como $y$ es vecino del vértice (ya visitado) $x$, ya llamamos a $agregarCandidato$ para $y$ iterando sobre $x$. Por lo tanto, o el camino mínimo que tenemos calculado para $y$ es el mínimo para $x$ seguido de la arista que va de $x$ a $y$, o encontramos en algún momento uno mejor. Por lo que vale:
\\
\begin{center}
\textbf{III)} $dist(y) \leq dist(x) + L(xy)$
\\
\end{center}
Por último, como $u$ fue el primer elemento sacado de la cola de prioridad que no pertenece a $V$, tiene menor o igual distancia al estado inicial que el resto de todos los que no pertenecen tampoco a $V$:
\\
\begin{center}
\textbf{IV)} $dist(u) \le dist(y) $
\\
\end{center}
Combinando II) con I) tenemos:
\\
\begin{center}
$dist(x)+L(xy) < dist(u)$
\\
\end{center}
Usando IV) y III) llegamos a:
\\

\begin{center}
$dist(x)+L(xy) < dist(x) + L(xy)$
\\
\end{center}
\textbf{Absurdo}, entonces $Q$ no puede existir siendo menor a la distancia calculada para $u$ y por lo tanto $dist(u) = \delta(u) \QEDB$
\\

Por este mismo absurdo también se puede ver por qué la distancia calculada para cualquier vértice al momento de ser desencolado es, necesariamente, su distancia mínima. Al igual que en la demostración, si existiera otro camino más corto donde alguno de sus vértices todavía no fuera visitado, entonces este vértice no podría estar detrás del estado actual (que viene por un camino distinto) en la cola de prioridad. Como este camino alternativo tendría todavía que llegar al estado final, tiene que sumar \textbf{al menos} una arista más, y como este peso es necesariamente positivo entonces la distancia total no puede ser nunca menor que el tope de la cola de prioridad que se corresponde con la distancia mínima calculada para el próximo estado actual. Partiendo de esto, como guardamos para cada vértice visitado su distancia mínima y solamente encolamos en $agregarCandidato$ cuando la nueva distancia de un hijo es menor que la calculada anteriormente, tenemos asegurado que tampoco vamos a pasar por un estado una vez que este fuera visitado con su mínima distancia.

\subsection{Complejidad}
Antes de empezar a iterar tenemos que inicializar los dos vectores de booleanos que determinan posiciones de arqueólogos y caníbales. Esto nos cuesta $\mathcal{O}(N+M)$. \\

El peor caso teórico sería aquel en el que tuvieramos que visitar todos los estados configurables del grafo (asumiendo que todos fueran posibles y no fueran podados) y tener que encolar/actualizar todas las distancias por cada estado generado por cada par posible.

La cantidad de estados totales que tendremos será $2^{N+M+1}$ porque por cada arqueólogo, caníbal y linterna pueden o ser $True$ o $False$. \\

El costo de actualizar una distancia, asumiendo que todos los estados están presentes en el diccioanrio y en el conjunto que usamos como cola de prioridad (ambos implementados sobre $Red/Black Trees$) es logarítimico en su cantidad de elementos: $\mathcal{O}(log(2^{N+M})) = \mathcal{O}(N+M)$. \\

La cantidad de pares de elementos de $A$ es cuadrática en sus elementos (contando la posibilidad de elegir dos veces al mismo, siendo un único elemento que cambie entre estados), ídem para $C$ y para pares mixtos hay $M*N$ combinaciones.

Por lo tanto tenemos un costo de $\mathcal{O}((N^2+M^2+N*M)*(N+M))=\mathcal{O}((N^3+M^3+N*M^2+M*N^2))=\mathcal{O}(N^3+M^3)$ para actualizar todos los estados $hijos$ posibles del estado actual. \\

Luego, en cada iteración desencolamos un estado nuevo estado y lo eliminamos del árbol. Por lo que dijimos antes respecto de los árboles, esto tiene un costo de orden $\mathcal{O}(N+M)$. \\

Juntando todo nos queda una complejidad de $\mathcal{O}(Inicializar\ vectores\ +\ Cantidad\ de\ estados*(Desencolar\ nuevo\ estado\ + Insertar\ hijos)) = \mathcal{O}((N+M)+2^{N+M}((N+M)+(N^3+M^3))) = \mathcal{O}(\ 2^{N+M}*(N^3+M^3)\ )$

\subsection{Análisis experimental}
