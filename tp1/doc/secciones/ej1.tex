\section{Problema 1: Cruzando el puente}

\subsection{Introducción}
	En este problema, Indiana Jones, quien se encuentra en la búsqueda de una antigua civilización persa junto con su grupo de arqueólogos, se alía a una tribu local para poder llegar juntos a la fortaleza que resguarda los secretos que tanto anhelan encontrar. En el camino, deben cruzar un peligroso puente que les presenta las siguientes dificultades:
	\begin{itemize}
	\item El estado del puente se ve bastante precario, por lo cual, para evitar riesgos, solo pueden pasar dos personas a la vez
	\item Es de noche y el grupo cuenta con solo una linterna
	\item La tribu que los ayuda es conocida por su canibalismo. Si en algún lado del puente quedan más caníbales que arqueólogos, estos terminarán siendo comidos
	\item Cada persona puede cruzar el puente a una velocidad fija. Si dos personas cruzan el puente, lo harán a la velocidad del que sea más lento
	\end{itemize}
	El objetivo del problema es encontrar el tiempo mínimo necesario para que todos los integrantes del equipo lleguen a salvo al otro lado del puente.

	En las siguientes secciones, llamaremos estado a la ubicacion de cada arqueologo, junto con su velocidad, la ubicacion de cada canibal junto con su velocidad y la ubicacion de la estado

	Podemos representar cada estado como un vector de N+M+1 booleanos, donde los primeros N valores son donde estan cada arqueologo, los siguientes M valores donde estan los canibales y el ultimo valor representa donde esta la linterna. Y a su vez, cada estado puede ser pensado como el vertice de un grafo y las aristas como el tiempo necesario para ir de un estado inicial a ese.	

	Formalmente, esto equivale a hallar el camino minimo entre 2 vertices particulares de un grafo.

\subsection{Solucion y Correctitud}	
	

	Para resolver el problema, lo que haremos es tener una de prioridad minima de  (Estado,Costo) y usaremos el costo para determinar la prioridad de cada elemento.
	Empezamos encolando el estado inicial y mientras haya elementos en la cola haremos lo siguiente.
	Se desencola el primer elemento, se mira su estado, si es el estado que estamos buscando, devolvemos el costo y termina.
	En caso contrario, a partir del estado que obtuvimos, nos generamos todos los siguientes estados posibles junto con el tiempo necesario para llegar del estado inicial a ese y el ciclo vuelve a empezar.
	En caso de no quedar mas elementos en la cola y no se haya encontrado una solucion se devuelve -1.
	A continuacion, presentamos un pseudo codigo de nuestro algoritmo.
	

\lstset{basicstyle=\large}
\begin{lstlisting}
	TiempoMinimo (Vector<int> arq, vector<int> can,estado res)

	TotalArq $\leftarrow$ arq.size
	TotalCan $\leftarrow$ can.size
	inicial $\leftarrow$ vector(TotalArq+TotalCan+1,false)
	distancia $\leftarrow$ CrearDicc(estado,int)
	candidatos $\leftarrow$ CrearConj(int,estado)
	Definir(distancia,inicial,0)
	Ag(candidatos,0,inicial)

	while candidatos $\neq$ $\emptyset$ do

		actual $\leftarrow$ Min(candidatos)
		borrar(actual,candidatos)
		if actual $\eq$ res
			devolver actual.costo
		else
	for cadaEstadoSiguientePosible do
		AgregarCandidato(distancia,candidatos,Tiempo(e),e)

\end{lstlisting} 

Seudo codigo para generar todas las siguientes estados posibles
\lstset{basicstyle=\large}

\begin{lstlisting}
TO DO
\end{lstlisting} 

\lstset{basicstyle=\large}
\begin{lstlisting}
	AgregarCandidato (Diccionario (estado,int) dicc ,Conjunto(int,estado) cola,int t, estado e)

	esta $\leftarrow$ esta?(dicc,e)
	if esta
			TiempoActual $\leftarrow$ Obtener(dicc,e)
				if t < TiempoActual
					Borrar(dicc,e)
					Borrar(cola,<Tiempo,e>)
 
	Definir(e,costo)
	Agregar(costo,e)

\end{lstlisting} 

Esta funcion tiene un costo de O (Log(n)), buscar en un diccionario arboreo es de orden logaritmico si esta balanceado, comparar 2 enteros es O(1) 2 inserciones
y en ciertos casos 2 borrados, cada una de esas operaciones es del orden logaritmico


Correctitud

Veamos que el algoritmo es correcto. Vamos a probar que nuestro algoritmo
obtiene el tiempo necesario para alcanzar cualquier vertice, en particular
para el vertice que buscamos.

Vamos a usar induccion en la cantidad de nodos visitados en el grafo.
Sea d(v), el camino obtenido por el algoritmo hasta v , sea L(v), el camino minimo hasta v y sea R el conjunto de nodos visitados hasta el momento . Lo que tenemos que probar es que d(v)=L(v) para todo vertice del grafo. Vamos a probarlo mediante induccion con el siguiente lema

% Estoy martillando esta dem  
% https://web.engr.oregonstate.edu/~glencora/wiki/uploads/dijkstra-proof.pdf


Lema : Para todo v $\in$ V , d(v) = L(v)

Caso Base: Un solo nodo visitado
El unico momento donde tenemos un unico nodo visitado es al comienzo, es decir el nodo donde empezamos, el cual tiene distancia 0 y es correcto.
Hipotesis Inductiva
Nuestra H.I es que para todo nodo explorado hasta el momento, nuestra distancia
hallada es la minima.
Paso Inductivo
Sea u el ultimo nodo agregado a V . Sea V'=V + u, necesitamos probar que d(u) = L(u)
para terminar.
Vamos por el absurdo, supongamos que nuestro algoritmo no encuentra el camino minimo,
supongamos que el camino minimo hasta u es Q y por lo tanto vale que
Largo(Q)<d(u) 
Q empieza en V y en algun momento sale de V para llegar a u.Sea xy el primer par de aristas donde Q sale de V. Sea Q´ el 