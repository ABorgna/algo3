\section{Problema 1: Cruzando el puente}


            \begin{itemize}
                \item Solo pueden pasar dos personas a la vez.
                \item En cada cruce es necesario contar con la única linterna presente.
                \item No puede suceder que en algún lado del puente queden más caníbales que arqueólogos.
                \item Cada persona puede cruzar el puente a una velocidad particular. Si dos personas cruzan el puente, lo harán a la velocidad del que sea más lento.
            \end{itemize}

        El objetivo del problema es encontrar el tiempo mínimo necesario para que todos los integrantes del equipo lleguen, cumpliendo los requisitos anteriores, al otro lado del puente.
        \\

        En las siguientes secciones llamaremos $estado$ a la ubicación de: la linterna, cada arqueólogo y cada caníbal respecto del lado inicial.

        Podemos representar cada estado como una tupla $(A,C,L)$, donde $A$ y $C$ son dos vectores de tamaño N y M respectivamente que indican, con un bool, si la ubicación del i-ésimo arqueólogo $A_i$ o caníbal $C_i$ es la del lado final y $L$  indica la ubicación de la linterna. Por lo tanto, cuando todas valgan $True$, habremos llegado al lado final (la linterna no puede terminar del lado inicial porque requeriría que alguien la haya llevado en el último cruce). Ademas, por enunciado, un estado válido tendrá que cumplir:
        \\

        $\sum_{i=0}^{N}\beta(A_i) > 0 \Rightarrow \sum_{i=0}^{N}\beta(A_i) \ge \sum_{i=0}^{M}\beta(C_i)  $
        \ \ \
        $\wedge$
        \ \ \
        $\sum_{i=0}^{N}\beta(\neg A_i) > 0 \Rightarrow \sum_{i=0}^{N}\beta(\neg A_i) \ge \sum_{i=0}^{M}\beta(\neg C_i)$
        \\

        Para cada persona $k$, sabemos su velocidad $V_k$. También sabemos que la demora de llevar el par $\left \langle {X, Y} \right \rangle$, con $\{X,Y\} \subseteq A \cup C$ de un lado a otro corresponde a $Max\{ V_{X}, V_{Y}  \}$ y es, a su vez, la distancia entre dos estados distintos. De este modo, podemos modelar todas las secuencias de viajes posibles como un digrafo ponderado con estados como vértices y donde cada arista es un viaje con peso equivalente a la distancia entre sus vértices adyacentes. De este grafo, finalmente, buscamos la distancia mínima de todos los caminos desde el estado inicial al final que cumplen los requisitos comentados al principio.
        \\

\subsection{Solución y Correctitud}
    \subsubsection{Solución}

    Para resolver el problema, utilizamos una mecánica basada en el algoritmo de Dijkstra para encontrar caminos mínimos en grafos. La idea es recorrer el grafo empezando desde el estado inicial, conservando el invariante de que conocemos la distancia mínima desde el inicio hasta todos los nodos ya visitados.

    Para ello mantenemos un $map\langle {estado,\ distancia} \rangle$ donde almacenamos los estados ya visitados o candidatos a visitar y su mejor distancia conocida desde el inicio, y un $set$ de tuplas $(distancia, estado)$ ordenado por distancia donde almacenamos los posibles candidatos para el siguiente paso de nuestro recorrido, los vecinos al subgrafo de nodos visitados, y la mejor distancia conocida.

    Recorremos el grafo seleccionando siempre de entre nuestros candidatos el que menor distancia conocida tenga. Como todas las aristas tienen peso positivo, cualquier otro camino que descubramos mas tarde hasta el nodo tendrá una distancia mayor, por lo que podemos asegurar que ya encontramos la mínima. Para cada estado que visitamos debemos corroborar que sea válido, ignorándolo si no cumple las propiedades detalladas anteriormente. Si por lo contrario es un estado válido podemos agregar a la lista de candidatos todos sus vecinos para los cuales la distancia resultante de agregar la arista incidente al camino mínimo que llega al nodo actual es menor a la mejor distancia conocida, reemplazando su entrada como candidato si ya existiera una.

    Si en algún momento visitamos el nodo final, ya sabemos la distancia mínima hasta este por nuestro invariante y podemos detener la búsqueda. Si por otro lado nos quedamos sin candidatos antes de llegar al nodo final podemos asegurar que no existe un camino hasta este, y por lo tanto no existe solución.
\\

\begin{lstlisting}
def TiempoMinimo (vector<int> arq, vector<int> can)
    map<estado,int> $menorDistancia$
    set<(distancia,estado)> $candidatos$
    marcar la $menorDistancia$ al estado inicial como 0
    agregar el estado inicial a $candidatos$

    while quedan candidatos:
        ($dist$,$actual$) $\leftarrow$ min($candidatos$)
        borrar ($dist$,$actual$) de $candidatos$
        if $actual$ es el estado final: return $dist$

        contar cantidad de arqueologos y canibales de cada lado
        if hay mas canibales que arqueologos de un lado: continue // es un estado invalido

        estado $hijo$ $\leftarrow$ $actual$
        $hijo$.linterna $\leftarrow$ $\neg actual$.linterna
        for $i$ in [0... $arq$.size() ):
            if $actual$.arqueologos[$i$] $\neq actual$.linterna: continue
            $hijo$.arqueologos[$i$] $\leftarrow$ $hijo$.linterna
            for $j$ in [$i$... $arq$.size() ):
                if $actual$.arqueologos[$j$] $\neq actual$.linterna: continue
                $hijo$.arqueologos[$j$] $\leftarrow$ $hijo$.linterna
                $distanciaCandidato \leftarrow$ $dist$ + max(arq[$i$],arq[$j$])
                if $hijo$ tiene $menorDistancia$:
                    if $menorDistancia$[$hijo$] $\leq$ $distanciaCandidato$:
                        if $i \neq j$: $hijo$.arqueologos[$j$] $\leftarrow$ $actual$.linterna
                        continue
                    borrar ($menorDistancia$[$hijo$], $hijo$) de $candidatos$
                $menorDistancia$[$hijo$] $\leftarrow$ $distanciaCandidato$
                agregar ($distanciaCandidato$, $hijo$) a $candidatos$
                if $i \neq j$:
                    $hijo$.arqueologos[$j$] $\leftarrow$ $actual$.linterna
            $hijo$.arqueologos[$i$] $\leftarrow$ $actual$.linterna
        for $i$ in [0... $can$.size() ):
            if $actual$.canibales[$i$] $\neq actual$.linterna: continue
            $hijo$.canibales[$i$] $\leftarrow$ $hijo$.linterna
            for $j$ in [$i$... $can$.size() ):
                if $actual$.canibales[$j$] $\neq actual$.linterna: continue
                $hijo$.canibales[$j$] $\leftarrow$ $hijo$.linterna
                $distanciaCandidato \leftarrow$ $dist$ + max(can[$i$],can[$j$])
                if $hijo$ tiene $menorDistancia$:
                    if $menorDistancia$[$hijo$] $\leq$ $distanciaCandidato$:
                        if $i \neq j$: $hijo$.canibales[$j$] $\leftarrow$ $actual$.linterna
                        continue
                    borrar ($menorDistancia$[$hijo$], $hijo$) de $candidatos$
                $menorDistancia$[$hijo$] $\leftarrow$ $distanciaCandidato$
                agregar ($distanciaCandidato$, $hijo$) a $candidatos$
                if $i \neq j$:
                    $hijo$.canibales[$j$] $\leftarrow$ $actual$.linterna
            $hijo$.canibales[$i$] $\leftarrow$ $actual$.linterna
        for $i$ in [0... $arq$.size() ):
            if $actual$.arqueologos[$i$] $\neq actual$.linterna: continue
            $hijo$.arqueologos[$i$] $\leftarrow$ $hijo$.linterna
            for $j$ in [$0$... $can$.size() ):
                if $actual$.canibales[$j$] $\neq actual$.linterna: continue
                $hijo$.canibales[$j$] $\leftarrow$ $hijo$.linterna
                $distanciaCandidato \leftarrow$ $dist$ + max(arq[$i$],can[$j$])
                if $hijo$ tiene $menorDistancia$:
                    if $menorDistancia$[$hijo$] $\leq$ $distanciaCandidato$:
                        $hijo$.canibales[$j$] $\leftarrow$ $actual$.linterna
                        continue
                    borrar ($menorDistancia$[$hijo$], $hijo$) de $candidatos$
                $menorDistancia$[$hijo$] $\leftarrow$ $distanciaCandidato$
                agregar ($distanciaCandidato$, $hijo$) a $candidatos$
                $hijo$.canibales[$j$] $\leftarrow$ $actual$.linterna
            $hijo$.arqueologos[$i$] $\leftarrow$ $actual$.linterna

    return -1 // no hay solucion

\end{lstlisting}

Como tanto el $map$ usado para almacenar las distancias como el $set$ de candidatos están implementados internamente con un $RB-tree$, las operaciones de inserción, borrado y búsqueda son de orden logarítmico en la cantidad de elementos y se puede acceder al mínimo en tiempo constante.

    \subsubsection{Correctitud}

Veamos que el algoritmo es correcto. Vamos a probar que obtiene siempre la distancia mínima a cualquier vértice del grafo. De ser así, podemos asegurar que el menor camino encontrado para el estado final en particular es efectivamente el mínimo.
\\

Vamos a usar inducción en la cantidad de vértices (estados) visitados en el grafo.
Sea $dist(v)$ la distancia desde el estado inicial obtenida por el algoritmo hasta el vértice $v$. Sea $\delta(v)$, el peso del camino mínimo hasta $v$ y sea $V$ el conjunto de vértices visitados hasta el momento: tenemos que probar que $dist(v) = \delta(v)$ para todo vértice del grafo. Vamos a probarlo mediante induccion con el siguiente lema:
\\

% Estoy martillando esta dem
% https://web.engr.oregonstate.edu/~glencora/wiki/uploads/dijkstra-proof.pdf

\begin{center}
\textbf{Lema: } $\forall$ $v \in$ $V$, $dist(v) = \delta(v)$
\end{center}

\emph{\textbf{Caso Base: }}  Un único vértice visitado. El único momento donde tenemos un solo nodo visitado es al comienzo, es decir
el estado inicial, el cual tiene distancia 0 (por definición) y es correcto trivialmente.
\\

\emph{\textbf{Hipótesis inductiva: }} Para todo vértice explorado anteriormente (es decir que está en $V$) nuestra distancia hallada es la mínima.
\\

\emph{Paso Inductivo:} Sea $u$ el último nodo agregado a $V$. Sea $V'= V + u$, necesitamos probar que $dist(u) = \delta(u)$ para terminar. Vamos por el absurdo, supongamos que nuestro algoritmo no encuentra el camino minimo: Supongamos que hay un camino más corto hasta $u$ que es $Q$, por lo tanto afirmamos sobre la longitud del camino $Q$, $L(Q)$, que
\\
\begin{center}
\textbf{I)} $L(Q) < dist(u)$
\\
\end{center}
Como $Q$ parte del estado inicial, que llamaremos $S$, y $S \in V$, entonces sabemos que $Q$ empieza en $V$ y en algún momento sale de $V$ para llegar a $u$. Sea $xy$ la primer arista donde $Q$ sale de $V$. Sea $Q_x$ el subcamino de $Q$ con todos sus vértices en $V$, es decir, el subcamino de $Q$ desde $s$ a $x$. Entonces:
\\
\begin{center}
$L(Q_x)+L(xy) \leq L(Q)$
\\
\end{center}
Aplicando H.I, $dist(x)$ es la distancia mínima desde $S$ hasta $x$: $dist(x) \leq L(Q_x)$ y por lo tanto, usando la desigualdad anterior:
\\
\begin{center}
\textbf{II)} $dist(x)+L(xy) \leq L(Q) $
\\
\end{center}
Como $y$ es vecino del vértice (ya visitado) $x$, ya llamamos a $agregarCandidato$ para $y$ iterando sobre $x$. Por lo tanto, o el camino mínimo que tenemos calculado para $y$ es el mínimo para $x$ seguido de la arista que va de $x$ a $y$, o encontramos en algún momento uno mejor. Por lo que vale:
\\
\begin{center}
\textbf{III)} $dist(y) \leq dist(x) + L(xy)$
\\
\end{center}
Por último, como $u$ fue el primer elemento sacado de la cola de prioridad que no pertenece a $V$, tiene menor o igual distancia al estado inicial que el resto de todos los que no pertenecen tampoco a $V$:
\\
\begin{center}
\textbf{IV)} $dist(u) \le dist(y) $
\\
\end{center}
Combinando II) con I) tenemos:
\\
\begin{center}
$dist(x)+L(xy) < dist(u)$
\\
\end{center}
Usando IV) y III) llegamos a:
\\

\begin{center}
$dist(x)+L(xy) < dist(x) + L(xy)$
\\
\end{center}
\textbf{Absurdo}, entonces $Q$ no puede existir siendo menor a la distancia calculada para $u$ y por lo tanto $dist(u) = \delta(u) \QEDB$
\\

Por este mismo absurdo también se puede ver por qué la distancia calculada para cualquier vértice al momento de ser desencolado es, necesariamente, su distancia mínima. Al igual que en la demostración, si existiera otro camino más corto donde alguno de sus vértices todavía no fuera visitado, entonces este vértice no podría estar detrás del estado actual (que viene por un camino distinto) en la cola de prioridad. Como este camino alternativo tendría todavía que llegar al estado final, tiene que sumar \textbf{al menos} una arista más, y como este peso es necesariamente positivo entonces la distancia total no puede ser nunca menor que el tope de la cola de prioridad que se corresponde con la distancia mínima calculada para el próximo estado actual. Partiendo de esto, como guardamos para cada vértice visitado su distancia mínima y solamente encolamos en $agregarCandidato$ cuando la nueva distancia de un hijo es menor que la calculada anteriormente, tenemos asegurado que tampoco vamos a pasar por un estado una vez que este fuera visitado con su mínima distancia.

\subsection{Complejidad}
Antes de empezar a iterar tenemos que inicializar los dos vectores de booleanos que determinan posiciones de arqueólogos y caníbales. Esto nos cuesta $\mathcal{O}(N+M)$. \\

El peor caso teórico sería aquel en el que tuvieramos que visitar todos los estados configurables del grafo (asumiendo que todos fueran posibles y no fueran podados) y tener que encolar/actualizar todas las distancias por cada estado generado por cada par posible.

La cantidad de estados totales que tendremos será $2^{N+M+1}$ porque por cada arqueólogo, caníbal y linterna pueden o ser $True$ o $False$. \\

El costo de actualizar una distancia, asumiendo que todos los estados están presentes en el diccioanrio y en el conjunto que usamos como cola de prioridad (ambos implementados sobre $Red/Black Trees$) es logarítimico en su cantidad de elementos: $\mathcal{O}(log(2^{N+M})) = \mathcal{O}(N+M)$. \\

La cantidad de pares de elementos de $A$ es cuadrática en sus elementos (contando la posibilidad de elegir dos veces al mismo, siendo un único elemento que cambie entre estados), ídem para $C$ y para pares mixtos hay $M*N$ combinaciones.

Por lo tanto tenemos un costo de $\mathcal{O}((N^2+M^2+N*M)*(N+M))=\mathcal{O}((N^3+M^3+N*M^2+M*N^2))=\mathcal{O}(N^3+M^3)$ para actualizar todos los estados $hijos$ posibles del estado actual. \\

Luego, en cada iteración desencolamos un estado nuevo estado y lo eliminamos del árbol. Por lo que dijimos antes respecto de los árboles, esto tiene un costo de orden $\mathcal{O}(N+M)$. \\

Juntando todo nos queda una complejidad de $\mathcal{O}(Inicializar\ vectores\ +\ Cantidad\ de\ estados*(Desencolar\ nuevo\ estado\ + Insertar\ hijos)) = \mathcal{O}((N+M)+2^{N+M}((N+M)+(N^3+M^3))) = \mathcal{O}(\ 2^{N+M}*(N^3+M^3)\ )$

\subsection{Análisis experimental}

En la anterior sección teorizamos un peor caso que forzaba a visitar y procesar cada estado que fuera posible dentro del grafo suponiendo que además también forzaría a actualizar, para las dos estructuras, todos los hijos de estos estados en cada iteración. Intentando buscar alguna manera de arreglar las velocidades de cada vector para generar condiciones similares (como por ejemplo, que el último estado en visitarse sea el final) nos encontramos con que no es trivial encontrar semejantes disposiciones. Aún así, apelando a ese análisis de complejidad, podemos aprovechar que se separa de la consideración de las velocidades (en tanto se generen estos peores casos) y termina siendo en función de los tamaños de los vectores. Por lo tanto generamos casos de test sobre combinaciones de tamaños para ambos vectores y randomizando las velocidades de cada componente. A partir de la cantidad de repeticiones podríamos llegar a considerar la \emph{probabilidad} de que se generen algunos de los peores casos mencionados anteriormente.	
\\

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{ej1}
    \caption{Tiempo de ejecución en función de la suma de cantidad de arqueólogos y cantidad de caníbales. Las velocidades de cada uno son generadas a partir de una distribución uniforme en cada muestra}
    \label{fig:ej1-fig}
\end{figure}

Las muestras de la figura \ref{fig:ej1-fig} se toman a partir de todas las combinaciones posibles de entre 0 y 10 elementos por cada vector, con al menos 2 repeticiones por caso. Es por esto que se pueden ver 'outliers' de muy bajo tiempo de ejecución, que se corresponden a los casos donde la cantidad de caníbales es mayor a la de arqueólogos y por lo tanto la poda de estados que no cumplan las condiciones de mayoría de arqueólogos por cada lado acaba por recortar todos los candidatos en las primeras iteraciones. 

Recordando que en la sección previa llegamos a una complejidad de orden $ \mathcal{O}(\ 2^{N+M}*(N^3+M^3)\ )$ y consideramos un eje de coordenadas $x = M + N$, sería acorde que si la cota estuviera bien ajustada pudieramos observar para cada combinación de tamaños de valor $x$ un tiempo de ejecución resultante de orden $ 2^{x}x^3 $. Por lo tanto, tomando un eje $y$ exponencial y despreciando el término cúbico, esperaríamos ver un gráfico lineal. Esto se condice con nuestras muestras.

