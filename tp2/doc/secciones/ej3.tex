\section{Problema 3: Escapando}

Luego de juntar todas las piezas, Indy llega a la cruz marcada en el mapa y se encuentra con una red de carritos que parecen dirigirse hacia afuera de la fortaleza, cuando de repente la fortaleza se empieza a derrumbar, asi que no tiene mas opcion que usar los carritos para escapar.

Los parámetros de entrada son los siguientes:

		\begin{itemize}
		\item Dos números N y M que representan la cantidad de estación y la cantidad de vías
		\item M lineas, las cuales contienen 3 enteros A,B y C que representan que ir de A a B tarda C segundos. Las estaciones se encuentran numeradas desde 1 hasta N
    		\end{itemize}

Los parámetros de salida son los siguientes:

	\begin{itemize}
	\item Un entero T que indica el tiempo mínimo necesario para escapar. En caso de que no haya camino, este valor deberá ser -1
	%\item Asumiendo que haya solución, la siguiente linea contendrá la cantidad de estaciones a recorrer.
	%\item Asumiendo que haya solución. Esta linea deberá contener la secuencia de las estaciones a recorrer.
	\item Si hay solución, la siguiente linea contendrá la cantidad de estaciones a recorrer y la siguiente linea contendrá la secuencia de estaciones a recorrer
	\end{itemize}

La solución tiene que tener una complejidad temporal de $\mathcal{O}(N^{2}log^{2}(N))$ o mejor.

\subsection{Solución}

Vamos a modelar el problema mediante grafos dirigidos. Si pensamos a las estaciones como los vértices y el tiempo necesario para ir de una estación a otra como el peso de la arista dirigida correspondiente, resulta que el problema se reduce a calcular el camino mínimo entre la estación 1 (donde están ubicados) y la estación n , a la cual quieren llegar.

%Si bien parece trivial, no sabemos si hace falta aclararlo.
La longitud del camino es la sumatoria de las aristas que usa, por lo dicho anteriormente esto equivale al tiempo necesario para recorrer dicho camino, esto seria la primera linea de la salida.

Para poder devolver la secuencia, vamos a tener un array de predecesores, que contendrá para todo los nodos del camino solución, desde qué nodo llegué.

Para resolver el problema vamos a aplicar un algoritmo de camino mínimo en grafos, en este caso vamos a usar Dijkstra, ya que todas las aristas tienen peso positivo.

\begin{lstlisting}
    $visitados$ $\gets$ vector[n,false]
    $tiempo\_min$ $\gets$ vector[n, $\infty$]
    $padre$ $\gets$ vector[n,-1]

    $tiempoMin$[0] = 0

    while $true$:
        $estacion\_actual$ $\gets$ $-1$
        $tiempo\_actual$ $\gets$ $\infty$

        for $j$ in [0..n) do
            If $j$ no fue visitado y $tiempo\_min$[$j$] < $tiempo\_actual$
                $estacion\_actual$ = $j$
                $tiempo\_actual$ = $tiempo\_min$[j]
        Si no encontre un candidato sin visitar y con $tiempo\_min$ $\neq \infty$
            break

        Marco el $nodo\_actual$ como visitado

        Si es el nodo buscado
            return el tiempo necesario

        for $a$ in lista de adyacencia de $nodo\_actual$
            $tiempo\_nuevo$ $\gets$ a $a$ desde $nodo\_actual$
            Si $tiempo\_nuevo$ < $tiempo\_min$[$a$]:
                actualizo el tiempo\_min[$a$]
                actualizo el padre de $a$

    return -1
   \end{lstlisting}

\subsection{Correctitud}

La demostración del algoritmo se vio en las clases teóricas de la materia.

\subsection{Complejidad}
Antes que nada, tenemos que inicializar las estructuras que vamos a utilizar.

Generar la listas de adyacencia.

Generar los 3 arrays visitados,TiempoMin y padre, lleva tiempo lineal en la cantidad de entradas, hay que pedir la memoria y luego recorrer linealmente cada array para insertar el valor que queremos.

Luego tenemos un ciclo,  veamos su costo.

Buscar cual va a ser el siguiente nodo visitado es lineal hay que recorrer todo el arreglo e ir comparando. Cabe aclarar que dentro de esta parte solo se comparan enteros y bool que se realiza en tiempo constante.

Luego se hacen 2 comparaciones, una detectar el caso de que no pueda seguir y no haya solución y la otra para ver si encontré el nodo buscado. Estas comparaciones, se realizan en tiempo constante pues es comparar 1 entero en cada una.

Luego,  sigue un for que itera sobre los vecinos del nodo actual . Este for tiene un costo lineal en la cantidad de vecinos del nodo, ya que lo de adentro se puede acotar por una constante.


\subsection{Experimentación}
Según el enunciado, el tiempo del algoritmo depende únicamente de la cantidad de estaciones  (nodos) , así que un experimento valido es fijar un n y ir generando distintos tipos de grafos y evaluar su tiempo de ejecución.

Otro tipo de experimento es ver si el peso de las aristas tienen impacto significativo en los tiempos de ejecución.

